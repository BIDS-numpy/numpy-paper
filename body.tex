Two Python array packages existed before NumPy.
The Numeric package began in the mid-90s and provided an array object in
Python, written in C, and linking to standard fast implementations of linear
algebra.
Around 2000, the Space Telescope Science Institute (STScI) software group wrote
a reimplementation of much of Numeric, called NumArray, to support their work
on large memory-mapped arrays and arrays of mixed data type
records \cite{STScI-slither}.
This briefly caused the two communities to diverge, until
2005, when NumPy emerged as a ``best of both worlds'' unification of Numeric
and NumArray \cite{oliphant2006guide}.

Today, NumPy underpins almost every Python library that does scientific or
numerical computation including SciPy \cite{virtanen2019scipy},
Matplotlib \cite{hunter2007matplotlib}, pandas \cite{mckinney-proc-scipy-2010},
scikit-learn \cite{pedregosa2011scikit}, and
scikit-image \cite{vanderwalt2014scikit}.
It is a community developed, open source library, which provides a
multidimensional Python array object along with array-aware functions
that operate on it.
Because of its inherent simplicity, the NumPy array is
the {\it de facto} exchange format for array data in Python.
The library has such widespread adoption that not only the array object but also its
{\it Application Programming Interface} (API) has become ubiquitous as
a language for array programming.

\section*{NumPy arrays}

\begin{figure*}
  \centering
  \includegraphics[width=\textwidth]{static/sketches/array-concepts}   
  \caption{\textbf{Fundamental Array Concepts.}
    \textbf{a,} The NumPy array data structure and its associated metadata fields.
    \textbf{b,} Indexing an array with various types of arguments.
    \textbf{c,} Indexing with arrays, which broadcast the indexing arguments before performing the lookup.
    \textbf{d,} Broadcasting in scalar addition, and in the division of two-dimensional arrays.
    \textbf{e,} Reduction operations act along one or more axes. In this
    example, a three-dimensional array is shown to be summed along various single
    axes to produce two-dimensional results, or along two axes consecutively to
    produce a one-dimensional result.
   }
  \label{fig:array-concepts}
\end{figure*}

The NumPy array is a data structure that efficiently stores and accesses
multidimensional arrays \cite{vanderwalt2011numpy}, also known as tensors, that
enables a wide variety of scientific computation.
It consists of a pointer to memory, along with metadata used to interpret the
data stored there, notably {\em data type}, {\em shape}, and {\em strides}
(Fig.~\ref{fig:array-concepts}a).

The \emph{data type} describes the nature of elements stored in an array.
An array has a single data type, and each array element occupies the same
number of bytes in memory.
Examples of data types include real and complex numbers (of lower and higher
precision), strings, timestamps, and pointers to Python objects.

The \emph{shape} of an array determines the number of elements along each axis,
and the number of axes is the array's dimensionality.
For example, a vector of numbers can be stored as a one dimensional array of
shape $N$, while color videos are four dimensional arrays of shape
$(T, M, N, 3)$.

\emph{Strides} are necessary to interpret computer memory, which stores elements
linearly, as multidimensional arrays.
It describes the number of bytes to move forward in memory to jump from row to
row, column to column, and so forth.
Consider, for example, a 2-D array of floating point numbers with shape
$(4, 3)$, where each element occupies 8 bytes in memory.
To move between consecutive columns we need to jump forward 8 bytes in memory,
and to access the next row $3 \times 8 = 24$ bytes.
The strides of that array are therefore $(24, 8)$.  NumPy is able to
store arrays in either C or Fortran memory order, iterating
first over either rows or columns.  This allows external libraries
written in those languages to directly access NumPy array data in memory.

Users interact with NumPy arrays using {\em indexing} (to access
subarrays or individual elements), {\em operators} (e.g., $+$, $-$, $\times$
for elementwise operations and $@$ for matrix multiplication), as well as {\em array-aware functions};
together, these provide an easily readable, expressive, high-level API for
array programming, while NumPy
deals with the underlying mechanics of making operations fast.

\emph{Indexing} an array returns single elements, subarrays, or elements that satisfy
a specific condition (Fig.~\ref{fig:array-concepts}b).
Arrays can even be indexed using other arrays (Fig.~\ref{fig:array-concepts}c).
Wherever possible, indexing that retrieves a subarray returns a {\em view} on
the original array, such that data is shared between the two arrays.
This provides a powerful way to operate on subsets of array data, while
limiting memory usage.

To complement the array syntax, NumPy includes functions that perform
elementwise calculations on arrays, including arithmetic, statistics, and
trigonometry.
They aim to loop over array elements near-optimally, taking into consideration,
e.g., strides, in order to best utilize the computer's fast cache memory.
Vectorized operations that would take many tens of lines to express in
languages such as C can often be implemented as a single, clear Python
expression.

When performing an elementwise operation (such as addition) on two arrays, one
expects that these arrays should have the same shape.
However, through \emph{broadcasting}, NumPy allows the dimensions to differ, while
still producing results that appeal to intuition.
A trivial example is the addition of a scalar value to an array, but it also
generalizes to more complex examples such as scaling each column of an array,
or generating a grid of coordinates.
In broadcasting, one or both arrays are virtually duplicated (that is, without
copying any data in memory), so that the shapes of the operands match
(Fig.~\ref{fig:array-concepts}d).
Broadcasting is also applied whenever an array is indexed using arrays of
indices (Fig.~\ref{fig:array-concepts}c).

Many of the array-aware functions, such as summation, support \emph{reductions}: aggregating
results across one or more dimensions of the array.
For example, summing a $n$-dimensional array over $d$ axes results in a
$(n-d)$-dimensional array (Fig.~\ref{fig:array-concepts}e).

Other array-aware functions include creating, reshaping, concatenating, and padding
arrays; searching, sorting and counting data; and reading and writing files.
NumPy provides extensive support for generating pseudorandom numbers and
includes an assortment of probability distributions.
It also performs accelerated linear algebra, utilizing one of several backends
such as OpenBLAS \cite{wang2013augem,xianyi2012model} and Intel MKL optimized for the CPUs at hand.


\section*{Scientific Python ecosystem}


% - review supporting the ecosystem (actual support element)
%   - docstrings / testing / packaging
%   - coordinating mechanism
%     - deprecation policy

The expressive power and brevity of NumPy's array programming syntax combined with 
an advanced interactive environment like IPython \cite{perez2007ipython}
or Jupyter \cite{Kluyver:2016aa} makes interactive data exploration fluid and simple.
It is common for NumPy users to work interactively with their data,
discovering through experimentation bits of code that they stich together into
imperative or functional programs.
Exposing array programming primitives, as well as the surrounding ecosystem of
tools, in Python---an interpreted language---creates an ideal environment for
interactive, exploratory data analysis where users may iteratively inspect,
manipulate, and visualize their data.


\begin{figure}
  \centering
  \includegraphics[width=.48\textwidth]{static/ecosystem}
  \caption{\textbf{Scientific Python Ecosystem.}
   }
  \label{fig:ecosystem}
\end{figure}


The scientific Python ecosystem (Fig.~\ref{fig:ecosystem}) is composed of many different libraries.
SciPy provides fundamental algorithms for scientific computing on arrays
including many mathematical, scientific, and engineering routines.
SciPy and NumPy are closely related and were developed together often
by the same people.
Matplotlib generates publication-ready figures and visualizations.
Employing these array-aware libraries are widely used
technique-specific libraries\cite{pedregosa2011scikit,vanderwalt2014scikit,SciPyProceedings_11}
and several domain-specific projects and
libraries \cite{astropy:2013,astropy:2018,cock2009biopython,millman2007analysis,2018EGUGA..2012146H}.
This has made the scientific Python ecosystem popular for scientific
research.

%These libraries can roughly be organized into three layers:
%core libraries, technique-specific libraries, and domain-specific libraries.

%SciPy adds various mathematical, scientific, and engineering routines;
%Matplotlib generates publication-ready figures and visualizations,
%Pandas provides indexed arrays, known as dataframes; and
%xarray implements arrays with labeled axes.

% we should have an example of how these tools may all be used in an
% example analysis.  maybe one of the ones mentioned in the abstract?

For example, the \code{eht-imaging} library developed by the Event Horizon Telescope 
collaboration relies on many components of the scientific Python ecosystem.
NumPy arrays are used to store and manipulate numerical data at every step
in the processing chain: from raw data through calibration and image 
reconstruction.
Scipy is used to provide tools used in general image processing such as 
filtering and image alignment, while scikit-image provided higher-level
functionality such as edge filters and Hough transforms.
Other components of Scipy are used throughout the library, such as the
\code{scipy.optimize} package for handling general optimization tasks.
NetworkX \cite{SciPyProceedings_11} is used for image comparisons.
Astropy \cite{astropy:2013, astropy:2018} is used in quite a few places,
primarily for I/O and time/coordinate transformations.
Matplotlib is used for visualizing data throughout the analysis pipeline,
including the generation of the final image of the black hole.
% N.B. - most of this comes from introspecting the Image class defined in
% ehtim/image.py. 

Tools for analyzing data from gravitational wave observatories such as LIGO
and Virgo are provided by the \code{pycbc} package, which was used in the first
detection of gravitationaly waves \cite{abbott2016observation} and in 
on-going analysis of data from LIGO and Virgo.
\code{pycbc} make extensive use of the scientific Python ecosystem.
The time-series data from the interferometers are stored in NumPy arrays,
while the \code{scipy.signal} is used to construct and apply filters to the
data.
Matplotlib is used to visualize data at all points along the analysis chain
including raw data from the instrumentation and the time-frequency 
visualization of the ``chirp'' from the binary black hole merger.

The rich ecosystem of tools building on NumPy and the larger community
of scientists and programmers using those tools mean that NumPy has a
responsibility to maintain considerable stability.
This need creates interesting challenges for NumPy development as the
computational environment scientists are analyzing their data on continues
to evolve and change.

\section*{Proliferation of arrays}

%\fixme{Add references somewhere to Zarr, https://arrow.apache.org/,
%https://parquet.apache.org/,
%https://github.com/ruby-numo/numo-narray/wiki/Comparison-with-Numpy}

Recent years have seen a massive explosion in data science, machine learning,
and artificial intelligence.  NumPy and its API, underlying almost every tool
in the computational toolchain, has become ubiquitous.  Still, NumPy itself
could never hope to satisfy every single specialized need of the community; it
is limited in its ability to work with very large datasets, datasets split
across multiple systems, and computations that require specialized hardware.
Furthermore, pursuing solutions to these challenges is out of scope for NumPy
development.

The community's efforts to fill the resultant gaps therefore led to a
proliferation of arrays including distributed arrays---which are stored on
multiple computers, GPU arrays---which utilize graphics processing units for
fast computation, computation graphs---which postpone and combine calculations
before executing them efficiently, and sparse arrays---which typically contain
few non-zero values, and store only those in memory.
%distributed arrays, GPU arrays, delayed execution arrays, sparse arrays,
%foreign language arrays, and more.

This includes popular tensor computation libraries such as
CuPy, JAX, and Apache MXNet.
PyTorch and Tensorflow provide tensor APIs with NumPy-inspired semantics.
% \footnote{\url{https://cupy.chainer.org/}}
% \footnote{\url{https://jax.readthedocs.io/en/latest/jax.numpy.html}}
% \footnote{\url{https://numpy.mxnet.io/}}
% \footnote{\url{https://pytorch.org/tutorials/beginner/blitz/tensor\_tutorial.html}}
% \footnote{\url{https://www.tensorflow.org/tutorials/customization/basics}}

\section*{Interoperability and extensibility}

NumPy supports array operations between external array objects by
acting as a central coordination mechanism with a well-specified API.
With the proliferation of array implementations discussed above, a
widespread adoption of the NumPy API is valuable: it lowers the
barrier to entry for newcomers and provides the wider community with a
stable array programming interface. This, in turn, prevents disruptive
schisms like the divergence of Numeric and NumArray, by facilitating
the development of specialized solutions and new tools that operate in
concert.

Primarily, there
exist two types of Python array objects: (1) arrays that mimic NumPy arrays but are
fundamentally different and (2) subclasses of NumPy arrays.

There has been a steady increase in the number of external libraries that
provide arrays and a NumPy-like API for manipulating them.
Ideally, operating on these arrays using NumPy would simply work, so that end
users could write code once, and would then benefit from switching between
NumPy arrays, GPU arrays, distributed arrays, and so forth, as appropriate.

\begin{figure}
  \centering
  \includegraphics[width=.45\textwidth]{static/sketches/duck-arrays}
  \caption{\textbf{Interoperability.} \fixme{This figure needs work.}}\label{fig:duck-arrays}
\end{figure}


To facilitate \emph{interoperability}, the NumPy team has designed
``protocols'' (or contracts of operation), that allow for these arrays to be
passed to NumPy functions (Fig.~\ref{fig:duck-arrays}).
NumPy, in turn, dispatches operations to the originating library, as required.
% FIXME: expand to 3 or more sentences discussing current efforts and
% issues with those, how did adoption go, what is being done next
%\url{https://numpy.org/neps/nep-0037-array-module.html}
Versions of these protocols have been successfully deployed.
% Ralf: Could you provide some proof of effectiveness, e.g., "This has made it
% possible to create distributed GPU arrays, enabling .... [find a reference to
% work by Peter Entschev]".

% https://numpy.org/neps/nep-0016-abstract-array.html
% https://numpy.org/neps/nep-0018-array-function-protocol.html
% https://numpy.org/neps/nep-0022-ndarray-duck-typing-overview.html
% https://numpy.org/neps/nep-0030-duck-array-protocol.html
% https://github.com/numpy/numpy/blob/a111b551ae940d7d5f8523fef1cf3589c6ba00a0/doc/neps/nep-0033-extensible-dtypes.rst
% https://numpy.org/neps/nep-0037-array-module.html

Subclasses of NumPy often exist due to difficulty in constructing richer data
types, such as quantities with physical units \cite{astropy,Goldbaum2018,pint},
geometrical objects \cite{pygeos}, and missing numbers.
To improve \emph{extensibility}, we are currently overhauling the data type
system to make it easier to implement data types both in Python and C, and to
support these and other applications.

\section*{Discussion}

NumPy was initially developed by students, faculty, and researchers to
provide an advanced, open source array programming library for Python,
which was free to use and unencumbered by license servers, dongles, and the like.
There was a sense of building something
impactful together, for the benefit of many others.  Participating in
such an endeavor, within a welcoming community of like-minded
indivuals, held a powerful attraction for many early contributors.

These user-developers frequently had to write code from scratch to solve
their or their colleagues' problems---often in low-level languages
that preceded Python, like Fortran \cite{dongarra2008netlib} and C.
To them, the advantages of an interactive, high-level array library
were evident. The design of this new tool was informed by their
experiences with powerful interactive programming languages for
scientific computing such as APL \cite{iverson1962programming} and
Yorick \cite{munro1995using}, as well as commercial languages and
environments like IDL and Matlab.

NumPy has subsequently seen prolific adoption, with millions of users,
first from research and later also industry.
It spurred the development of the larger scientific Python ecosystem and
heralded the current era of wide-spread use of Python for scientific computing.
The reasons for its success are varied and complex, but include the fact that
NumPy (a) is built on top of Python,
(b) has a strong culture of collaboration and good software development practices, and
(c) provides a cutting-edge array programming environment for scientific data analysis.

\emph{Python} is an open source, general-purpose, interpreted programming language
well-suited to standard programming tasks such as cleaning data,
interacting with web resources, and parsing text.
Adding fast array operations and linear algebra allows scientist to do all
their work within a single language---and one that has the advantage of
being famously easy to learn and teach.
In fact, Python's adoption as a primary learning language in universities
(e.g., many lower division UC Berkeley courses use Python including
Foundations of Data Science,
The Beauty and Joy of Computing,
Introduction to Computational Thinking with Data,
and The Structure and Interpretation of Computer Programs) has
further popularized NumPy as a tool of choice for modern data science.

Even though NumPy is not part of Python's standard library,
we benefit from a good relationship with the Python developers.
Over the years, the Python language has added new features and
special syntax so that NumPy would have more succinct and 
easy to read array notation.
Since we are not part of the standard library, we are able to
dictate our own release policies and development patterns.
%\fixme{we've gotten a number of features: slicing syntax, implicit tuples,
%complex numbers, buffer protocol, matrix multiplication operator}
%\fixme{but we benefit from separate governance}

NumPy is a community of practice with a strong \emph{culture} of
employing software engineering practice to improve collaboration and
reduce error \cite{millman2014developing}.  This culture is not only
adopted by leaders in the project, but also enthusiastically taught to
newcomers. The NumPy team was early in adopting distributed revision
control and code review to improve collaboration on code, and
continuous testing that runs a large battery of automated tests for
every proposed change to NumPy.  The project has comprehensive,
high-quality documentation, integrated with the source
code \cite{vanderwalt2008scipy,harrington2008scipy,harrington2009scipy}.

% https://ras.ac.uk/sites/default/files/2020-01/Group%20Award%20-%20Astropy.pdf
% https://ras.ac.uk/news-and-press/news/leading-astronomers-and-geophysicists-honoured-ras-bicentenary-year-0

This culture of using best practices for producing reliable scientific software
has been eagerly adopted by the ecosystem of libraries that build on NumPy.
For example, in a recent award given by the Royal Astronomical Society to
Astropy, they state:
\begin{quotation}
\noindent\emph{The Astropy Project has provided hundreds of junior scientists
with experience in professional-standard software development practices
including use of version control, unit testing, code review and issue tracking
procedures. This is a vital skill set for modern researchers that is often
missing from formal university education in physics or astronomy.}
\end{quotation}
Community members explicitly work to address this lack of formal education
through formal courses and workshops
\cite{wilson-software-carpentry,hannay-scientific-software-survey,millman2018teaching}.

NumPy combines the expressive power of \emph{array programming}, 
the performance of C, and the Python programming language in a mature,
well-tested, well-documented, and community developed library.
It builds on decades of work refining the array programming
syntax from APL through Yorick and others.
It also made it easy for other libraries to develop fast and
memory-efficient compiled code, usually in C or Fortran, that could manipulate
these arrays and pass them back to Python.
Popular array-aware libraries increased the user community and that
in turn led to more libraries adding new functionality
to the scientific Python ecosystem.


Over time the role of the NumPy has evolved. It is no longer just the
foundational array library underlying the scientific Python ecosystem,
but it is also a standard API for tensor computation and a
central coordinating mechanism between array types and technologies.
